## Redis <Badge text="P1" type="warning"/> `(7/19)`

redis 未查到，数据也未查到需要记录 key 防止多次穿透

- 讲一下 Redis 集群高可用、主从复制的理解
  - https://xiaolincoding.com/redis/cluster/master_slave_replication.html
- redis 做补偿的时候挂了怎么办
- redis 数据结构 用在哪些场景？说一下五种 redis 数据结构和之间的实现方式
  - https://xiaolincoding.com/redis/data_struct/data_struct.html
  - https://xiaolincoding.com/redis/data_struct/command.html
  - https://xiaolincoding.com/redis/base/redis_interview.html#redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84
- 热 key 问题的解决
- 哨兵
- redis 和数据库数据不一致（延迟双删 binlog）
  - https://xiaolincoding.com/redis/cluster/master_slave_replication.html#%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4
- redis 秒杀场景
  - https://xiaolincoding.com/cs_learn/feel_cs.html#%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1
- Redis 这块，如果你作为一个 Redis 管理者，对使用有什么建议吗
- redis 的缓存双写一致性你如何保证
  - https://xiaolincoding.com/redis/architecture/mysql_redis_consistency.html
  - https://xiaolincoding.com/redis/base/redis_interview.html#redis-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1
- 选一个常用类型说一下底层实现
- redis 跳表、动态字符串
- redis 的过期时间 TTL，是谁来负责更新的？就比如过期时间是 100，是什么负责把它更新为 99 呢？
- redis 惊群效应
- redis 的内存回收
  - 内存淘汰策略共有八种，分为「不进行数据淘汰」和「进行数据淘汰」两类策略
    - 不进行数据淘汰的策略（noeviction）
    - 进行数据淘汰的策略，分为「在设置了过期时间的数据中进行淘汰」和「在所有数据范围内进行淘汰」这两类策略
      - 过期时间的数据中进行淘汰
        - volatile-random：随机淘汰设置了过期时间的任意键值
        - volatile-ttl：优先淘汰更早过期的键值
        - volatile-lru：淘汰所有设置了过期时间的键值中，最久未使用的键值
        - volatile-lfu：淘汰所有设置了过期时间的键值中，最少使用的键值
      - 在所有数据范围内进行淘汰
        - allkeys-random：随机淘汰任意键值
        - allkeys-lru：淘汰整个键值中最久未使用的键值
        - allkeys-lfu：淘汰整个键值中最少使用的键值
- redis 怎么知道这个 key 已经过期了（过期字典「惰性删除+定期删除」）
  - 被动过期 尝试去访问一个过期了的 key，此时这个 key 会被删除
  - 主动过期 https://redis.io/commands/expire/
    - Redis 会定期 *TODO_* 的在设置了过期时间的 key 中随机挑选测试一些 key，已过期的 key 删除
    - Redis 每秒会执行 10???? 次下面的步骤
      - 在设置了过期时间的 key 中随机挑选 20 个 key 测试
      - 删除所有已过期的 key
      - 如果有超过 25% 的 key 过期，重复第一步
        - 概率算法，假设样本代表整个 key space，Redis 继续过期直到可能过期的 key 百分比低于 25％
        - 在任意给定时刻，使用内存的已过期 key 的最大数量最大等于每秒最大写入操作数量除以 4。
- redis 的分布式锁你了解多少
  - 加锁包括了读取锁变量、检查锁变量值和设置锁变量值 SETNX
  - 锁变量需要设置过期时间
  - 锁变量的值需要能区分来自不同客户端的加锁操作
  - Redlock
- redis 持久化机制
  - AOF（AOF 重写机制、AOF 重写缓冲区、AOF 缓冲区、AOF 重写子进程）
  - RDB（save、bgsave）
- redis 缓存穿透、击穿和雪崩以及对应的解决方案
  - 穿透：数据既不在缓存中，也不在数据库中时有大量访问
    - 限制非法请求
    - 缓存空值或者默认值
    - 布隆过滤器 TODO
  - 击穿：热点数据过期
    - 不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间
    - 互斥锁方案，保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值
  - 雪崩：大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机，全部请求都直接访问数据库
    - 大量数据同时过期：均匀设置过期时间、互斥锁、双 key 策略、后台更新缓存（类似缓存预热）
    - Redis 故障宕机：服务熔断、请求限流、构建 Redis 集群
- redis 为什么更快，持久化方式，redis 单线程在多核机器里使用会不会浪费机器资源
  - 基于内存的数据库，对数据的读写操作都是在内存中完成，因此读写速度非常快
  - AOF 日志：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；RDB 快照：将某一时刻的内存数据，以二进制的方式写入磁盘；混合持久化方式：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点
  - CPU 并不是制约 Redis 性能表现的瓶颈所在，更多情况下是受到内存大小和网络I/O的限制
- string
- list
- set
- zset
- bitmap
- hyperloglog
- map