# 协程

::: info 开始之前
- 协程是什么？
- 为什么需要协程？
- 协程解决了什么问题？
:::

## 进程与线程

操作系统运行一个程序，会启动一个进程，并且会为进程分配进程地址空间、文件描述符等，？

每个进程都会有一个主线程，在发生系统调用时，CPU 会切换成内核态，在进程虚拟空间中的内核栈执行，完成系统调用后会恢复线程保存的用户栈现场，并恢复成用户态继续执行。

### 缺点

- 操作机系统调度切换线程如果属于不同进程时，需要同时切换页表，页目录修改后，TLB 缓存会失效，造成地址转换效率降低，影响性能
- 当线程数量激增，线程内核栈和用户栈会占用大量内存，且基于时间片的调度策略下，如果是 IO 密集型应用，在时间片未用完就发生调度，调度的开销就会大大增加，影响吞吐量

基于以上问题，为了满足减小内存，且调度代价低的要求，协程就被创建出来了。

## 协程

Golang 是集协程思想和 IO 多路复用技术实现 goroutine。

### IO 多路复用

以 linux 中的 epoll 为例，在对 socket 读写前，使用 `epoll_ctl` 将 socket 描述符添加到 epoll 中，然后通过 `epoll_wait` 监听等待，当 socket 可读、可写时，`epoll_wait` 就会返回一组已经触发的 `epoll_event`。通过批量监听，避免了非阻塞式 IO 频繁轮询空耗 CPU，也不会像阻塞式 IO 每个 socket 都挂起一个线程。

对于 `epoll_wait` 返回的事件列表，需要遍历处理与之关联的 socket，有的是读，有的是写，有的可能读了一部分，需要继续等待后续的 `epoll_wait` 才能读完。Golang 将对 `epoll_event` 的事件循环隐藏到 runtime 内部，代码在执行 IO 时直接触发协程切换，切换到下一个已经就绪的协程。当执行事件循环时，找到已就绪的 socket 对应的协程继续执行，循环往复。

### netpoll

- 