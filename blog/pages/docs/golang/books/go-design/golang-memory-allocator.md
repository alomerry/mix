---

---

# 内存管理

- 线性分配器
  - 标记压缩（Mark-Compact）算法：这种算法分为两个阶段，标记和压缩。在标记阶段，程序遍历所有的对象并标记那些仍然被引用的对象。在压缩阶段，程序将所有存活的对象移动到内存的一端，将未使用的内存释放出来。这种算法会导致内存碎片化，但是可以最大限度地利用可用内存。
  - 复制回收（Copying GC）算法：这种算法将内存分为两个区域，一半用于分配内存，另一半用于垃圾回收。当内存用完时，程序将所有存活的对象复制到未使用的内存区域中，然后释放已使用的内存。这种算法不会导致内存碎片化，但是需要更多的内存空间。
  - 分代回收（Generational GC）算法：这种算法根据对象的年龄将内存分为几个代。新分配的对象被放置在第一代中，如果对象经过多次垃圾回收仍然存活，则将其移动到下一代中。这种算法利用了大多数对象的短暂生命周期，因此可以更快地回收垃圾。
- 空闲链表分配器
  - 首次适应（First-Fit）— 从链表头开始遍历，选择第一个大小大于申请内存的内存块；
  - 循环首次适应（Next-Fit）— 从上次遍历的结束位置开始遍历，选择第一个大小大于申请内存的内存块；
  - 最优适应（Best-Fit）— 从链表头遍历整个链表，选择最合适的内存块；
  - 隔离适应（Segregated-Fit）— 将内存分割成多个链表，每个链表中的内存块大小相同，申请内存时先找到满足条件的链表，再从链表中选择合适的内存块；
