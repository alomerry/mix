---
layout: Post
title: 走迷宫
subtitle: 
author: Alomerry Wu
date: 2018-07-16
headerImage: /img/in-post/2018-07-16/header.jpg
catalog: true
tags:
- Y2018
- 递归
---

<!-- Description. -->

<!-- more -->

## 问题 F: 【递归入门】走迷宫

### 题目描述

有一个 `n*m` 格的迷宫（表示有 `n` 行、`m` 列），其中有可走的也有不可走的，如果用 `1` 表示可以走，`0` 表示不可以走，文件读入这 `n*m` 个数据和起始点、 结束点（起始点和结束点都是用两个数据来描述的，分别表示这个点的行号和列号）。现在要你编程找出所有可行的道路，要求所走的路中没有重复的点，走时只能是上下左右四个方向。如果一条路都不可行，则输出相应信息（用 `-1` 表示无路）。 
请统一用 左上右下的顺序拓展，也就是 `(0,-1),(-1,0),(0,1),(1,0)`。

### 输入

第一行是两个数 `n,m(1<n,m<15)`，接下来是 `m` 行 `n` 列由 `1` 和 `0` 组成的数据，最后两行是起始点和结束点。

### 输出

所有可行的路径，描述一个点时用 `(x，y)` 的形式，除开始点外，其他的都要用 `->` 表示方向。
如果没有一条可行的路则输出 `-1`。

### 样例输入

```text
5 6
1 0 0 1 0 1
1 1 1 1 1 1
0 0 1 1 1 0
1 1 1 1 1 0
1 1 1 0 1 1
1 1
5 6
```

### 样例输出

```
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(2,5)->(3,5)->(3,4)->(3,3)->(4,3)->(4,4)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(2,5)->(3,5)->(3,4)->(4,4)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(2,5)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(3,4)->(3,3)->(4,3)->(4,4)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(3,4)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(3,4)->(4,4)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(3,4)->(2,4)->(2,5)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(3,4)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(3,4)->(4,4)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(4,3)->(4,4)->(3,4)->(2,4)->(2,5)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(4,3)->(4,4)->(3,4)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(4,3)->(4,4)->(4,5)->(5,5)->(5,6)
```

### Result

```cpp
#include <iostream>
#include <algorithm>
#include <map>
#include <vector>
using namespace std;
int mix[15][15], n, m, waysNum, dx[4] = {0, -1, 0, 1}, dy[4] = {-1, 0, 1, 0};
pair<int, int> in, out, now;
vector<pair<int, int> > rou;
void dfs(pair<int, int> now)
{
    rou.push_back(now);
    if (now == out)
    {
        for (int i = 0; i < rou.size(); i++)
        {
            cout << "(" << rou[i].first << "," << rou[i].second << ")";
            if (i != rou.size() - 1)
            {
                cout << "->";
            }
        }
        waysNum++;
        cout << endl;
        return;
    }
    for (int j = 0; j <= 3; j++)
    {
        if (mix[now.first+dx[j]][now.second+dy[j]] == 1){
            mix[now.first][now.second] = 0;
            dfs(pair<int,int>(now.first+dx[j],now.second+dy[j]));
            rou.pop_back();
            mix[now.first][now.second] = 1;
        }
    }
}
void clear()
{
    for (int i = 0; i <= 14; i++)
    {
        for (int j = 0; j <= 14; j++)
        {
            mix[i][j] = 0;
        }
    }
}
int main()
{
    int tempx, tempy;
    while (cin >> n)
    {
        cin >> m;
        waysNum = 0;
        clear();
        for (int i = 1; i <= n; i++)
        {
            for (int j = 1; j <= m; j++)
            {
                cin >> mix[i][j];
            }
        }
        cin >> tempx >> tempy;
        in = pair<int, int>(tempx, tempy);
        cin >> tempx >> tempy;
        out = pair<int, int>(tempx, tempy);
        dfs(in);
        if(waysNum == 0)
        cout<<-1<<endl;
    }
    return 0;
}
```
