---
layout: Post
title: CSAPP
subtitle:
author: Alomerry Wu
date: 2022-02-14
headerImage: /img/in-post/header-image/16.jpg
catalog: true
tags:
- Y2022
---

<!-- Description. -->

<!-- more -->

## 2 信息的表示和处理

### 2.1 信息存储

#### 2.1.2 字数据大小

每台计算机都有一个字长（word size），指明指针数据的标称大小（nominal size）。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的大小。也就是说，对于一个字长为 w 位的机器而言，虚拟地址的范围为 0 ~ 2^w^ - 1，程序最多访问 2^w^ 个字节。

程序员应该力图使他们的程序在不同的机器和编译器上可移植。可移植性的一个方面就是使程序对不同的数据类型的确切大小不敏感。C 语言标准对不同的数据类型的数字范围设置了下界，但是却没有上界。在 1980 到 2010 年间，许多程序的编写都假设为 32 为程序的字节分配。在将这些程序移植到新机器上时，许多隐藏的对字长的依赖性对体现出来，成为错误。

#### 2.1.3 寻址和字节顺序

对于跨越多字节的程序对象，需要描述这个对象的地址什么，以及在内存中如何排列这些字节。

排列表示一个对象的字节有两种通用的规则。某些机器选择在内存中按照从最低有效字节到最高有效字节的顺序存储对象，而另一些机器则按照从最高有效字节到最低有效字节的顺序存储。前者称为 _小端法_（little endian），后一种规则称为 _大端法_（big endia）。

例如变量 x 的类型为 int，位于地址 0x100 处，它的十六进制为 0x01234567。地址的范围 0x100 ~ 0x103 的字节顺序依赖于机器的类型：

**大端法**

| ...  | 0x100 | 0x101 | 0x102 | 0x103 | ...  |
| :--: | :---: | :---: | :---: | :---: | ---- |
| ...  |  01   |  23   |  45   |  67   | ...  |

**小端法**

| ...  | 0x100 | 0x101 | 0x102 | 0x103 | ...  |
| :--: | :---: | :---: | :---: | :---: | ---- |
| ...  |  67   |  45   |  23   |  01   | ...  |

对于大多数应用程序员来说，其机器所使用的的字节顺序是完全不可见的。不过有时，字节顺序会成为问题。

首先是不同类型的机器之间通过网络传输二进制数据时，一个常见的问题当小端法机器产生的数据被发送到大端法机器或者反过来时，接受程序会发现，里面的字节成了反序的。

第二种情况当阅读表示整数数据的字节序列时字节顺序也很重要。通常发生在检查机器级程序时。作为一个示例，从某个文件中摘出了下面这行代码，该文件给出了一个针对 Intel x86-64 处理器的机器级代码的文本表示：

```
4004d3:  01 05 43 0b 20 00    add %eax,0x200b43(%rip)
```

这一行是由 **反汇编器**（disassembler）生成的。十六进制字节串 `01 05 43 0b 20 00` 是一条指令的字节级表示，这条指令是把一个字长的数据加到一个值上，该值得存储地址由 0x200b43 加上当前程序计数器的值得到，当前程序计数器的值即为下一条将要执行执行的地址。取出这个序列的最后四个字节：43 0b 20 00，并按照相反的顺序写得到 00 20 0b 43。去掉开头的 0，得到值 0x200b43，这就是右边的数值。

字节顺序变得重要的第三种情况是当编写规避正常的类型系统的程序时。在 C 语言中可以通过强制类型转化或联合来允许以一种数据类型引用一个对象，而这种数据类型与创建这个对象时定义数据类型不同，大多数应用编程都不推荐这种编码技巧，但是它们对系统级编程来说是非常有用的。

