---
title: 第 83 场周赛
date: 2022-09-13
description:
timeline: false
article: false
category:
  - LeetCode
---

## [830\. 较大分组的位置](https://leetcode.cn/problems/positions-of-large-groups/)

### Description

Difficulty: **简单**

Related Topics: [字符串](https://leetcode.cn/tag/string/)


在一个由小写字母构成的字符串 `s` 中，包含由一些连续的相同字符所构成的分组。

例如，在字符串 `s = "abbxxxxzyy"` 中，就含有 `"a"`, `"bb"`, `"xxxx"`, `"z"` 和 `"yy"` 这样的一些分组。

分组可以用区间 `[start, end]` 表示，其中 `start` 和 `end` 分别表示该分组的起始和终止位置的下标。上例中的 `"xxxx"` 分组用区间表示为 `[3,6]` 。

我们称所有包含大于或等于三个连续字符的分组为 **较大分组** 。

找到每一个 **较大分组** 的区间，**按起始位置下标递增顺序排序后**，返回结果。

**示例 1：**

```
输入：s = "abbxxxxzzy"
输出：[[3,6]]
解释："xxxx" 是一个起始于 3 且终止于 6 的较大分组。
```

**示例 2：**

```
输入：s = "abc"
输出：[]
解释："a","b" 和 "c" 均不是符合要求的较大分组。
```

**示例 3：**

```
输入：s = "abcdddeeeeaabbbcd"
输出：[[3,5],[6,9],[12,14]]
解释：较大分组为 "ddd", "eeee" 和 "bbb"
```

**示例 4：**

```
输入：s = "aba"
输出：[]
```

**提示：**

*   `1 <= s.length <= 1000`
*   `s` 仅含小写英文字母


### Solution

Language: **C++**

@[code](@IOI/83/830-main.cpp)

## [831\. 隐藏个人信息](https://leetcode.cn/problems/masking-personal-information/)

### Description

Difficulty: **中等**

Related Topics: [字符串](https://leetcode.cn/tag/string/)


给你一条个人信息字符串 `s` ，可能表示一个 **邮箱地址** ，也可能表示一串 **电话号码** 。返回按如下规则 **隐藏** 个人信息后的结果：

_**电子邮件地址：**_

一个电子邮件地址由以下部分组成：

*   一个 **名字** ，由大小写英文字母组成，后面跟着
*   一个 `'@'` 字符，后面跟着
*   一个 **域名** ，由大小写英文字母和一个位于中间的 `'.'` 字符组成。`'.'` 不会是域名的第一个或者最后一个字符。

要想隐藏电子邮件地址中的个人信息：

*   **名字** 和 **域名** 部分的大写英文字母应当转换成小写英文字母。
*   **名字** 中间的字母（即，除第一个和最后一个字母外）必须用 5 个 `"*****"` 替换。

_**电话号码：**_

一个电话号码应当按下述格式组成：

*   电话号码可以由 10-13 位数字组成
*   后 10 位构成 **本地号码**
*   前面剩下的 0-3 位，构成 **国家代码**
*   利用 `{'+', '-', '(', ')', ' '}` 这些 **分隔字符** 按某种形式对上述数字进行分隔

要想隐藏电话号码中的个人信息：

*   移除所有 **分隔字符**
*   隐藏个人信息后的电话号码应该遵从这种格式：
    *   `"***-***-XXXX"` 如果国家代码为 0 位数字
    *   `"+*-***-***-XXXX"` 如果国家代码为 1 位数字
    *   `"+**-***-***-XXXX"` 如果国家代码为 2 位数字
    *   `"+***-***-***-XXXX"` 如果国家代码为 3 位数字
*   `"XXXX"` 是最后 4 位 **本地号码**


**示例 1：**

```
输入：s = "LeetCode@LeetCode.com"
输出："l*****e@leetcode.com"
解释：s 是一个电子邮件地址。
名字和域名都转换为小写，名字的中间用 5 个 * 替换。
```

**示例 2：**

```
输入：s = "AB@qq.com"
输出："a*****b@qq.com"
解释：s 是一个电子邮件地址。
名字和域名都转换为小写，名字的中间用 5 个 * 替换。
注意，尽管 "ab" 只有两个字符，但中间仍然必须有 5 个 * 。
```

**示例 3：**

```
输入：s = "1(234)567-890"
输出："***-***-7890"
解释：s 是一个电话号码。
共计 10 位数字，所以本地号码为 10 位数字，国家代码为 0 位数字。
因此，隐藏后的电话号码应该是 "***-***-7890" 。
```

**示例 4：**

```
输入：s = "86-(10)12345678"
输出："+**-***-***-5678"
解释：s 是一个电话号码。
共计 12 位数字，所以本地号码为 10 位数字，国家代码为 2 位数字。
因此，隐藏后的电话号码应该是 "+**-***-***-7890" 。
```

**提示：**

*   `s` 是一个 **有效** 的电子邮件或者电话号码
*   如果 `s` 是一个电子邮件：
    *   `8 <= s.length <= 40`
    *   `s` 是由大小写英文字母，恰好一个 `'@'` 字符，以及 `'.'` 字符组成
*   如果 `s` 是一个电话号码：
    *   `10 <= s.length <= 20`
    *   `s` 是由数字、空格、字符 `'('`、`')'`、`'-'` 和 `'+'` 组成


### Solution

Language: **C++**

@[code](@IOI/83/831-main.cpp)

## [829\. 连续整数求和](https://leetcode.cn/problems/consecutive-numbers-sum/)

### Description

Difficulty: **困难**

Related Topics: [数学](https://leetcode.cn/tag/math/), [枚举](https://leetcode.cn/tag/enumeration/)


给定一个正整数 `n`，返回 _连续正整数满足所有数字之和为 `n` 的组数_ 。

**示****例 1:**

```
输入: n = 5
输出: 2
解释: 5 = 2 + 3，共有两组连续整数([5],[2,3])求和后为 5。
```

**示例 2:**

```
输入: n = 9
输出: 3
解释: 9 = 4 + 5 = 2 + 3 + 4
```

**示例 3:**

```
输入: n = 15
输出: 4
解释: 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5
```

**提示:**

*   1 <= n <= 10<sup>9</sup>​​​​​​​


### Solution

Language: **C++**

@[code](@IOI/83/829-main.cpp)

## [828\. 统计子串中的唯一字符](https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/)

### Description

Difficulty: **困难**

Related Topics: [哈希表](https://leetcode.cn/tag/hash-table/), [字符串](https://leetcode.cn/tag/string/), [动态规划](https://leetcode.cn/tag/dynamic-programming/)


我们定义了一个函数 `countUniqueChars(s)` 来统计字符串 `s` 中的唯一字符，并返回唯一字符的个数。

例如：`s = "LEETCODE"` ，则其中 `"L"`, `"T"`,`"C"`,`"O"`,`"D"` 都是唯一字符，因为它们只出现一次，所以 `countUniqueChars(s) = 5` 。

本题将会给你一个字符串 `s` ，我们需要返回 `countUniqueChars(t)` 的总和，其中 `t` 是 `s` 的子字符串。输入用例保证返回值为 32 位整数。

注意，某些子字符串可能是重复的，但你统计时也必须算上这些重复的子字符串（也就是说，你必须统计 `s` 的所有子字符串中的唯一字符）。

**示例 1：**

```
输入: s = "ABC"
输出: 10
解释: 所有可能的子串为："A","B","C","AB","BC" 和 "ABC"。
     其中，每一个子串都由独特字符构成。
     所以其长度总和为：1 + 1 + 1 + 2 + 2 + 3 = 10
```

**示例 2：**

```
输入: s = "ABA"
输出: 8
解释: 除了 countUniqueChars("ABA") = 1 之外，其余与示例 1 相同。
```

**示例 3：**

```
输入：s = "LEETCODE"
输出：92
```

**提示：**

*   `1 <= s.length <= 10^5`
*   `s` 只包含大写英文字符


### Solution

Language: **C++**

@[code](@IOI/83/828-main.cpp)
