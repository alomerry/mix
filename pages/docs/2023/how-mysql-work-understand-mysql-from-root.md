---
date: 2023-09-30T16:00:00.000+00:00
title: MySQL 是怎样运行的 从根儿上理解 MySQL
duration: 2min
wordCount: 824
---

## 启动选项和系统变量

## 字符集和比较规则

## InnoDB 记录存储结构

## InnoDB 数据页结构

- 记录页
- 页目录 Page Directory
- 页面头部 Page Header
- 文件头部 File Header
- 文件尾部 File Trailer

## B+ 树索引

## B+ 树索引的使用

索引减小扫描记录数量时，先找到索引执行查询时对应的扫描区间和形成该扫描取件的边界条件

### 更好地创建索引和使用索引

- 索引列类型尽量小
- 索引只用于搜索、排序或分组
- 考虑索引列中不重复值的个数
- 为列前缀简历索引
- 覆盖索引
- 索引列以列名的形式在搜索条件中单独出现

## MySQL 数据目录

## InnoDB 表空间

## 单表访问方法

- const 主键或唯一二级索引常数等值比较
- ref 二级索引常数等值比较
- ref_or_null 二级索引常数等值比较，包含 NULL 值
- range 索引范围扫描为单点区间或者范围区间
- index 扫描全部二级索引（包含全表扫描时 order by 主键）
- all 全表扫描

### 索引合并

#### intersection 索引合并

多个二级索引的主键值交集，即多个二级索引的主键值都是有序的，可以合并后再回表，减小回表次数

- 有序集合交集相对容易
- 有序主键回表不再是随机 I/O

#### union 索引合并

多个二级索引的主键值并集，即多个二级索引的主键值都是有序的，需要先合并后再回表，减小回表次数

#### sort-union 索引合并

多个二级索引主键值排序后的并集

## 连接的原理

- join buffer

## 基于成本的优化

查询成本 = 1.0 * I/O 成本 + 0.2 * CPU 成本

某个表的全表扫描聚簇索引成本

I/O 成本 = 读取聚簇索引页数（show table status 中的 Data_length / 16k /1024）* 1.0 + 微调
CPU 成本 = 扫描行数（show table status 中的 Rows / 16k /1024） * 0.2 + 微调

二级索引还要加上二级索引成本

连接查询成本 = 单次访问驱动表成本 + 单次访问被驱动表成本 * 驱动表扇出值

## InnoDB 统计数据收集

## 基于规则的优化、子查询优化

- 条件简化
  - 删除不必要括号
  - 常量传递
  - 移除无效条件
  - 表达式计算
  - 合并 having 和 where 子句
  - 常量表检测（MyISAM）
- 外连接消除

### 子查询优化

按返回结果集区分子查询

- 标量子查询 仅返回值
- 行子查询 返回行
- 列子查询 返回列
- 表子查询 返回表

按与外层查询关系区分子查询

- 不相关子查询
- 相关子查询

### in 子查询优化

- 将子查询结果放入中间表并去重（不大时在内存中使用 hash 索引）
- 将子查询结果物化转连接
- 将子查询转换为半连接
  - 子查询表上拉
  - 重复值消除 Duplicate Weedout
  - 松散扫描
  - 半物化连接
  - 首次匹配

## Explain 详解

## optimizer trace

## buffer pool

## 事务简介

## redo 日志

## undo 日志

## 事务隔离级别和 MVCC

## 锁

- 表级锁
  - 表锁
  - 元数据锁
  - 意向锁
  - 隐式锁
- 行级锁
  - Record Lock（S/X）
  - Gap Lock
  - Next-key Lock
  - 插入意向锁
